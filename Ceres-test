#include <iostream>
#include <ceres/ceres.h>
#include <Eigen/Core>
#include <Eigen/Geometry>

// 基本Sim3类，表示相似变换
class Sim3 {
public:
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
    
    Sim3() : 
        q_(Eigen::Quaterniond::Identity()),
        t_(Eigen::Vector3d::Zero()),
        s_(1.0) {}
        
    Sim3(const Eigen::Quaterniond& q, const Eigen::Vector3d& t, double s) : 
        q_(q), t_(t), s_(s) { q_.normalize(); }
        
    // 基本访问器
    inline const Eigen::Quaterniond& quaternion() const { return q_; }
    inline Eigen::Matrix3d rotation() const { return q_.toRotationMatrix(); }
    inline const Eigen::Vector3d& translation() const { return t_; }
    inline double scale() const { return s_; }
    
    // 应用变换到一个点
    Eigen::Vector3d map(const Eigen::Vector3d& p) const {
        return s_ * (q_ * p) + t_;
    }
    
    // 逆变换
    Sim3 inverse() const {
        Eigen::Quaterniond q_inv = q_.conjugate();
        Eigen::Vector3d t_inv = -(q_inv * t_) / s_;
        return Sim3(q_inv, t_inv, 1.0/s_);
    }
    
    // 右乘操作符
    Sim3 operator*(const Sim3& other) const {
        Eigen::Quaterniond q_res = q_ * other.quaternion();
        Eigen::Vector3d t_res = s_ * (q_ * other.translation()) + t_;
        double s_res = s_ * other.scale();
        return Sim3(q_res, t_res, s_res);
    }
    
private:
    Eigen::Quaterniond q_; // 旋转四元数
    Eigen::Vector3d t_;    // 平移向量
    double s_;             // 尺度因子
};

// 测试Sim3流形
class TestSim3Manifold : public ceres::Manifold {
public:
    TestSim3Manifold(bool fix_scale = true) : fix_scale_(fix_scale) {}
    
    virtual ~TestSim3Manifold() {}
    
    virtual int AmbientSize() const { return 8; }
    virtual int TangentSize() const { return fix_scale_ ? 6 : 7; }
    
    virtual bool Plus(const double* x, const double* delta, double* x_plus_delta) const {
        // 提取当前参数
        Eigen::Vector3d t(x[0], x[1], x[2]);
        Eigen::Quaterniond q(x[6], x[3], x[4], x[5]); // w, x, y, z
        q.normalize();
        double s = x[7];
        
        // 提取delta增量
        Eigen::Vector3d omega(delta[0], delta[1], delta[2]); // 旋转增量
        Eigen::Vector3d dt(delta[3], delta[4], delta[5]);    // 平移增量
        double ds = fix_scale_ ? 0.0 : delta[6];            // 尺度增量
        
        // 创建旋转增量四元数
        double theta = omega.norm();
        Eigen::Quaterniond dq;
        if (theta > 1e-10) {
            omega = omega / theta; // 归一化旋转轴
            dq = Eigen::Quaterniond(
                cos(theta/2.0),
                sin(theta/2.0) * omega.x(),
                sin(theta/2.0) * omega.y(),
                sin(theta/2.0) * omega.z()
            );
        } else {
            dq = Eigen::Quaterniond(1.0, 0.0, 0.0, 0.0);
        }
        
        // 应用增量 - 关键是使用右乘更新
        Eigen::Quaterniond q_new = q * dq;
        q_new.normalize();
        
        double s_new = s * exp(ds);
        
        Eigen::Vector3d t_new = t + dt;
        
        // 存储更新后的结果
        x_plus_delta[0] = t_new.x();
        x_plus_delta[1] = t_new.y();
        x_plus_delta[2] = t_new.z();
        x_plus_delta[3] = q_new.x();
        x_plus_delta[4] = q_new.y();
        x_plus_delta[5] = q_new.z();
        x_plus_delta[6] = q_new.w();
        x_plus_delta[7] = s_new;
        
        return true;
    }
    
    virtual bool PlusJacobian(const double* x, double* jacobian) const {
        Eigen::Map<Eigen::Matrix<double, 8, Eigen::Dynamic, Eigen::RowMajor>> J(
            jacobian, 8, TangentSize());
        
        J.setZero();
        
        // 旋转Jacobian
        J.block<3, 3>(3, 0) = Eigen::Matrix3d::Identity();
        
        // 平移Jacobian
        J.block<3, 3>(0, 3) = Eigen::Matrix3d::Identity();
        
        // 尺度Jacobian (如果不固定)
        if (!fix_scale_) {
            J(7, 6) = x[7]; // s
        }
        
        return true;
    }
    
    virtual bool Minus(const double* y, const double* x, double* delta) const {
        // 提取参数 x
        Eigen::Vector3d t_x(x[0], x[1], x[2]);
        Eigen::Quaterniond q_x(x[6], x[3], x[4], x[5]); // w, x, y, z
        q_x.normalize();
        double s_x = x[7];
        
        // 提取参数 y
        Eigen::Vector3d t_y(y[0], y[1], y[2]);
        Eigen::Quaterniond q_y(y[6], y[3], y[4], y[5]); // w, x, y, z
        q_y.normalize();
        double s_y = y[7];
        
        // 计算旋转差异
        Eigen::Quaterniond q_delta = q_x.conjugate() * q_y;
        q_delta.normalize();
        
        // 转换到轴角
        Eigen::Vector3d omega;
        double angle = 2.0 * atan2(q_delta.vec().norm(), q_delta.w());
        if (q_delta.vec().norm() > 1e-10) {
            omega = angle * q_delta.vec() / q_delta.vec().norm();
        } else {
            omega.setZero();
        }
        
        // 计算平移差异
        Eigen::Vector3d dt = t_y - t_x;
        
        // 计算尺度差异
        double ds = log(s_y / s_x);
        
        // 存储增量
        delta[0] = omega.x();
        delta[1] = omega.y();
        delta[2] = omega.z();
        delta[3] = dt.x();
        delta[4] = dt.y();
        delta[5] = dt.z();
        
        if (!fix_scale_) {
            delta[6] = ds;
        }
        
        return true;
    }
    
    virtual bool MinusJacobian(const double* x, double* jacobian) const {
        Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, 8, Eigen::RowMajor>> J(
            jacobian, TangentSize(), 8);
        
        J.setZero();
        
        // 简单实现
        J.block<3, 3>(0, 3) = Eigen::Matrix3d::Identity();
        J.block<3, 3>(3, 0) = Eigen::Matrix3d::Identity();
        
        if (!fix_scale_) {
            J(6, 7) = 1.0 / x[7];
        }
        
        return true;
    }
    
private:
    bool fix_scale_;
};

// 简单的Sim3误差函数
struct TestSim3Error {
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
    
    TestSim3Error(const Sim3& measurement) : measurement_(measurement) {
        // 在这里，我们可以打印测量值的详细信息
        std::cout << "Measurement: " << std::endl;
        std::cout << "  Rotation: " << measurement.quaternion().w() << ", " 
                 << measurement.quaternion().x() << ", " 
                 << measurement.quaternion().y() << ", " 
                 << measurement.quaternion().z() << std::endl;
        std::cout << "  Translation: " << measurement.translation().transpose() << std::endl;
        std::cout << "  Scale: " << measurement.scale() << std::endl;
    }
    
    template <typename T>
    bool operator()(const T* const param_i, const T* const param_j, T* residuals) const {
        // 提取顶点i的Sim3参数
        Eigen::Map<const Eigen::Matrix<T, 3, 1>> t_i(param_i);
        Eigen::Quaternion<T> q_i(param_i[6], param_i[3], param_i[4], param_i[5]); // w, x, y, z
        q_i.normalize();
        T s_i = param_i[7];
        
        // 提取顶点j的Sim3参数
        Eigen::Map<const Eigen::Matrix<T, 3, 1>> t_j(param_j);
        Eigen::Quaternion<T> q_j(param_j[6], param_j[3], param_j[4], param_j[5]); // w, x, y, z
        q_j.normalize();
        T s_j = param_j[7];
        
        // 测量值转换为模板类型
        Eigen::Quaternion<T> q_meas(
            T(measurement_.quaternion().w()),
            T(measurement_.quaternion().x()),
            T(measurement_.quaternion().y()),
            T(measurement_.quaternion().z())
        );
        q_meas.normalize();
        
        Eigen::Matrix<T, 3, 1> t_meas(
            T(measurement_.translation().x()),
            T(measurement_.translation().y()),
            T(measurement_.translation().z())
        );
        
        T s_meas = T(measurement_.scale());
        
        // 计算相对Sim3变换: Sji = Sj * Si^-1
        // 首先计算Si^-1
        Eigen::Quaternion<T> q_i_inv = q_i.conjugate();
        Eigen::Matrix<T, 3, 1> t_i_inv = -(q_i_inv * t_i) / s_i;
        T s_i_inv = T(1.0) / s_i;
        
        // 然后计算Sji = Sj * Si^-1
        Eigen::Quaternion<T> q_ji = q_j * q_i_inv;
        q_ji.normalize();
        
        Eigen::Matrix<T, 3, 1> t_ji = s_j * (q_j * t_i_inv) + t_j;
        T s_ji = s_j * s_i_inv;
        
        // 计算误差: Sji * Smeas^-1
        // 首先计算Smeas^-1
        Eigen::Quaternion<T> q_meas_inv = q_meas.conjugate();
        
        // 旋转误差: log(q_meas^-1 * q_ji)
        Eigen::Quaternion<T> q_error = q_meas_inv * q_ji;
        q_error.normalize();
        
        // 转换四元数误差为轴角
        Eigen::Matrix<T, 3, 1> omega;
        T angle = T(2.0) * atan2(q_error.vec().norm(), q_error.w());
        
        if (q_error.vec().norm() > T(1e-10)) {
            omega = angle * q_error.vec() / q_error.vec().norm();
        } else {
            omega.setZero();
        }
        
        // 平移误差
        Eigen::Matrix<T, 3, 1> t_error = t_ji - t_meas;
        
        // 尺度误差
        T s_error = log(s_ji / s_meas);
        
        // 存储误差
        residuals[0] = omega.x() * T(10.0); // 放大旋转误差
        residuals[1] = omega.y() * T(10.0);
        residuals[2] = omega.z() * T(10.0);
        residuals[3] = t_error.x() * T(10.0); // 放大平移误差
        residuals[4] = t_error.y() * T(10.0);
        residuals[5] = t_error.z() * T(10.0);
        residuals[6] = s_error * T(10.0); // 放大尺度误差
        
        // 打印当前误差
        static int iteration = 0;
        if (iteration % 100 == 0) {
            std::cout << "Error " << iteration << ":" << std::endl;
            std::cout << "  Rotation error: " << omega.transpose() << std::endl;
            std::cout << "  Translation error: " << t_error.transpose() << std::endl;
            std::cout << "  Scale error: " << s_error << std::endl;
        }
        iteration++;
        
        return true;
    }
    
    static ceres::CostFunction* Create(const Sim3& measurement) {
        return new ceres::AutoDiffCostFunction<TestSim3Error, 7, 8, 8>(
            new TestSim3Error(measurement));
    }
    
private:
    Sim3 measurement_;
};

int main(int argc, char** argv) {
    // 创建几个具有已知相对位姿的关键帧
    std::vector<Sim3> keyframes;
    
    // 第一个关键帧作为世界坐标系的原点
    keyframes.push_back(Sim3(
        Eigen::Quaterniond::Identity(),
        Eigen::Vector3d::Zero(),
        1.0
    ));
    
    // 第二个关键帧：绕Z轴旋转30度，平移(1,0,0)，尺度1.1
    Eigen::Quaterniond q1(Eigen::AngleAxisd(M_PI/6, Eigen::Vector3d::UnitZ()));
    keyframes.push_back(Sim3(
        q1,
        Eigen::Vector3d(1.0, 0.0, 0.0),
        1.1
    ));
    
    // 将关键帧参数存储为可优化的参数块
    std::vector<double*> sim3_blocks;
    for (const Sim3& kf : keyframes) {
        double* block = new double[8];
        block[0] = kf.translation().x();
        block[1] = kf.translation().y();
        block[2] = kf.translation().z();
        block[3] = kf.quaternion().x();
        block[4] = kf.quaternion().y();
        block[5] = kf.quaternion().z();
        block[6] = kf.quaternion().w();
        block[7] = kf.scale();
        
        sim3_blocks.push_back(block);
    }
    
    // 复制原始块用于比较
    std::vector<double*> original_blocks;
    for (const double* block : sim3_blocks) {
        double* copy = new double[8];
        for (int i = 0; i < 8; i++) {
            copy[i] = block[i];
        }
        original_blocks.push_back(copy);
    }
    
    // 对第二个关键帧添加一些扰动
    sim3_blocks[1][0] += 0.1; // 平移x方向扰动
    sim3_blocks[1][1] += 0.2; // 平移y方向扰动
    sim3_blocks[1][7] *= 0.9; // 尺度扰动
    
    // 计算相对Sim3（从0到1）
    Sim3 kf0(
        Eigen::Quaterniond(original_blocks[0][6], original_blocks[0][3], 
                          original_blocks[0][4], original_blocks[0][5]),
        Eigen::Vector3d(original_blocks[0][0], original_blocks[0][1], original_blocks[0][2]),
        original_blocks[0][7]
    );
    
    Sim3 kf1(
        Eigen::Quaterniond(original_blocks[1][6], original_blocks[1][3], 
                          original_blocks[1][4], original_blocks[1][5]),
        Eigen::Vector3d(original_blocks[1][0], original_blocks[1][1], original_blocks[1][2]),
        original_blocks[1][7]
    );
    
    Sim3 kf1_kf0 = kf1 * kf0.inverse();
    
    std::cout << "Original relative transformation:" << std::endl;
    std::cout << "  Rotation: " << kf1_kf0.quaternion().w() << ", " 
             << kf1_kf0.quaternion().x() << ", " 
             << kf1_kf0.quaternion().y() << ", " 
             << kf1_kf0.quaternion().z() << std::endl;
    std::cout << "  Translation: " << kf1_kf0.translation().transpose() << std::endl;
    std::cout << "  Scale: " << kf1_kf0.scale() << std::endl;
    
    // 打印扰动后的参数
    std::cout << "\nDisturbed parameters:" << std::endl;
    for (int i = 0; i < sim3_blocks.size(); i++) {
        std::cout << "KeyFrame " << i << ":" << std::endl;
        std::cout << "  Translation: " << sim3_blocks[i][0] << ", " 
                 << sim3_blocks[i][1] << ", " << sim3_blocks[i][2] << std::endl;
        std::cout << "  Rotation: " << sim3_blocks[i][6] << ", " 
                 << sim3_blocks[i][3] << ", " << sim3_blocks[i][4] << ", " 
                 << sim3_blocks[i][5] << std::endl;
        std::cout << "  Scale: " << sim3_blocks[i][7] << std::endl;
    }
    
    // 设置优化问题
    ceres::Problem problem;
    
    // 添加参数块
    for (double* block : sim3_blocks) {
        problem.AddParameterBlock(block, 8, new TestSim3Manifold(true));
    }
    
    // 固定第一个关键帧
    problem.SetParameterBlockConstant(sim3_blocks[0]);
    
    // 添加相对Sim3约束
    ceres::CostFunction* cost_function = TestSim3Error::Create(kf1_kf0);
    problem.AddResidualBlock(cost_function, nullptr, sim3_blocks[0], sim3_blocks[1]);
    
    // 设置优化器参数
    ceres::Solver::Options options;
    options.linear_solver_type = ceres::DENSE_QR;
    options.minimizer_progress_to_stdout = true;
    options.max_num_iterations = 20;
    options.function_tolerance = 1e-10;
    options.gradient_tolerance = 1e-10;
    options.parameter_tolerance = 1e-10;
    
    // 为了修复问题，设置一个更合理的初始信任域半径
    options.initial_trust_region_radius = 1e-5;
    
    // 解决优化问题
    ceres::Solver::Summary summary;
    ceres::Solve(options, &problem, &summary);
    
    std::cout << summary.FullReport() << std::endl;
    
    // 打印优化后的参数
    std::cout << "\nOptimized parameters:" << std::endl;
    for (int i = 0; i < sim3_blocks.size(); i++) {
        std::cout << "KeyFrame " << i << ":" << std::endl;
        std::cout << "  Translation: " << sim3_blocks[i][0] << ", " 
                 << sim3_blocks[i][1] << ", " << sim3_blocks[i][2] << std::endl;
        std::cout << "  Rotation: " << sim3_blocks[i][6] << ", " 
                 << sim3_blocks[i][3] << ", " << sim3_blocks[i][4] << ", " 
                 << sim3_blocks[i][5] << std::endl;
        std::cout << "  Scale: " << sim3_blocks[i][7] << std::endl;
    }
    
    // 计算优化后的参数与原始参数之间的差异
    std::cout << "\nDifferences from original parameters:" << std::endl;
    for (int i = 0; i < sim3_blocks.size(); i++) {
        std::cout << "KeyFrame " << i << ":" << std::endl;
        std::cout << "  Translation: " 
                 << sim3_blocks[i][0] - original_blocks[i][0] << ", " 
                 << sim3_blocks[i][1] - original_blocks[i][1] << ", " 
                 << sim3_blocks[i][2] - original_blocks[i][2] << std::endl;
        
        // 四元数差异比较复杂，这里简单计算欧式距离
        double q_diff = sqrt(
            pow(sim3_blocks[i][3] - original_blocks[i][3], 2) +
            pow(sim3_blocks[i][4] - original_blocks[i][4], 2) +
            pow(sim3_blocks[i][5] - original_blocks[i][5], 2) +
            pow(sim3_blocks[i][6] - original_blocks[i][6], 2)
        );
        std::cout << "  Rotation quaternion distance: " << q_diff << std::endl;
        
        std::cout << "  Scale ratio: " 
                 << sim3_blocks[i][7] / original_blocks[i][7] << std::endl;
    }
    
    // 清理内存
    for (double* block : sim3_blocks) {
        delete[] block;
    }
    for (double* block : original_blocks) {
        delete[] block;
    }
    
    return 0;
}
